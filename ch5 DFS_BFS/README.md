# DFS/BFS
### Concepts
2차원 배열에서의 탐색 문제 -> 그래프 형태로 바꿔 생각해 볼 것 ex) 게임 맵
- 탐색: 많은 양의 데이터 중에 원하는 데이터를 찾는 과정
- 자료구조: 데이터를 표현하고 관리하고 처리하기 위한 구조
    - 삽입과 삭제
    - 오버플로와 언더플로

**스택**
- LIFO (나중에 들어온 것이 먼저 나감)
- list로 구현: append, pop

**큐**
- FIFO (먼저 들어온 것이 먼저 나감)
- list로 구현: append, pop(0)

**deque**
- `from collections import deque`
- 스택과 큐의 장점 모두 채택
- 데이터 넣고 빼는 속도가 리스트 자료형에 비해 효율적

**재귀 함수**
- 자기 자신을 다시 호출하는 함수
- 종료 조건을 잘 명시해야 함
- 컴퓨터 내 스택 자료구조를 이용하며, 재귀 호출 제한을 넘으면 Recursionerror가 발생한다

**그래프**
- 노드와 간선으로 이루어짐
- 인접 행렬 (노드가 연결된 형태)/ 인접 리스트(모든 연결된 노드 정보)로 구현

DFS와 BFS

**DFS**
- 깊이 우선 탐색, 그래프에서 깊은 부분부터 탐색
- 스택 자료구조, 재귀 함수 활용 구현
1. 탐색 시작 노드 스택에 삽입, 방문 처리
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그를 스택에 넣고 방문 처리. 없다면 스택에서 최상단 노드를 꺼냄
3. 스택이 빌 때까지 반복

**BFS**
- 너비 우선 탐색, 가까운 노드부터 탐색
- 큐 자료구조
1. 탐색 시작 노드 큐에 삽입, 방문 처리
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중 방문하지 않은 노드 모두 큐에 삽입, 방문처리
3. 큐가 빌 때까지 반복


### 예시 문제들
0. DFS 예시, BFS 예시 0_dfs_bfs.py
1. 음료수 얼려 먹기 1_ice_beverage.py
2. 미로 탈출 2_escape_maze.py


### 1. 음료수 얼려 먹기
나의 경우에는 visited 배열을 만들어서 했는데, 만들지 않고 그냥 입력 값에서 0 을 1로 바꾸어 주어 방문 처리를 해주면 공간을 절약할 수 있다.
DFS와 BFS 두 가지로 구현해 보았다.
**TODO**:
    성능 비교를 해보고 싶다!

### 2. 미로 탈출
이 경우도 visited를 만들었는데 cost가 1부터 시작해서 굳이 만들지 않아도 오류가 생기지 않았다.
아이디어는 그냥 BFS로 탐색을 하면서, cost를 1 씩 늘려 나가는 것이다. path가 있다면 마지막 오른쪽 아래 위치의 노드도 방문하여 값을 업데이트 할 수 있게 된다.
