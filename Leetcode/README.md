# LeetCode 1월 문제 풀이 목록
- 0120 valid_parenthesis.py


### 0120 Valid Parenthesis
- 아이디어
    스택에 쌓아 두고, 가장 오른쪽에 있는, 즉 가장 마지막에 있는 element와 매칭이 된다면 매칭된 스택의 마지막 원소를 지운다. 이렇게 하면 valid parenthesis만 있는 string의 경우 스택이 비게 된다.
    ex) stack의 마지막에 '{' 가 있었는데 '}'가 다음으로 들어왔다면 매칭되므로, 스택에서 '{'를 지운다

- 구현
    closing parenthesis마다 매칭되는 opening parenthesis를 스택으로 저장했다.
- 다른 사람의 풀이
    오히려 opening에 매칭이 되게 하자 코드가 훨씬 짧아졌다
    같은 insight인데도 조금의 다른 구현 방식 때문에도 코드의 가독성이 차이가 날 수 있다

### 0121 Find the Most Competitive Subsequence
- 아이디어
    내가 생각했던 아이디어는, 일단 주어진 리스트에서, 이전 단계에서 선택된 숫자 뒤면서, 그 뒤에 k - 1 개 이상의 원소가 있는 위치 중 가장 최솟값인 것들이 정답 시퀀스에 차례로 들어가면 된다고 생각했다. 생각이 틀린 것은 아니었지만 접근법이 달랐다. 나의 경우에는 각 경우마다 left와 right(limit)를 업데이트 해가며 min과 min값의 index를 찾는 연산이 필요했으므로 시간이 오래 걸렸다. 거의 O(mnlog(n)) 정도가 걸렸을 것으로 보인다 (m은 k, n은 리스트의 길이).
    다른 사람은 거의 O(n)의 시간으로 했는데, 직접 스택을 쌓아가면서 보다 큰 원소는 스택에서 제외하되, 그 제외하는 횟수를 제한하는 방식이었다.
- 구현
    left, right를 업데이트 하고 min, index로 찾는 식의 구현 -> 시간 초과
    =>
    다른 사람의 구현 참고 -> stack에 쌓으면서 pop횟수에 제한을 두고, 자신보다 더 큰 것이 앞에 있다면 pop해줌 차례로

### 0122 Determine if Two Strings Are Close
- 아이디어:
    각 문자들 끼리 위치 바꾸기 및 서로 바꾸기가 가능하다고 했으므로 문자열을 구성하는 문자들의 종류가 같고, 문자들의 갯수들이 같다면 즉, a 1개 b 2개 = b 1개 a 2개 (1개, 2개로 이뤄짐) 두 개의 string이 close라고 판별했다.
- 다른 사람의 구현에서는 one liner로 했다
- 흥미로웠던 점:
    Counter()로 각 리스트를 센 뒤 Counter.values()를 바로 비교하면 내용물이 똑같아도 같지 않다고 나왔다. 나는 따로 list를 만들어 주어 해결했다. 다른 사람의 경우 values()에 대한 카운터를 만들고 그 카운터가 같은지를 비교해서 한 줄로 끝냈다.