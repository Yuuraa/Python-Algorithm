### 3월 문제 풀이 목록
- [0301_distribute_candies.py]()
- [0302_set_mismatch.py]()
- [0303 missing_nums.py]()
- [0304 intersect_linked_list.py]()
- [0305 average_bintree.py]()
- [0306 short_encoding.py]()
- [0307 design_hashmap.py]()
- [0308 remove_palindrome.py]()

### 0301 Distribute Candies
- 문제: 전체 캔디 수의 절반 만을 먹을 수 있는 앨리스가, 먹을 수 있는 캔디 종류의 최댓값을 구하는 문제
- 나의 풀이: 간단히, 캔디 종류의 수와 n//2 중 더 적은 값이 먹을 수 있는 종류 수의 최댓값이라고 풀었다.
- 다른 사람의 풀이: 캔디 종류 수를 구할 때 set 대신 Counter를 사용했다

### 0302 Set Mismatch
- 문제: 원래 배열에는 1 ~ n 의 숫자가 모두 포함되어 있다. 하지만, 한 숫자가 중복되어 원래 있어야 할 숫자를 대체하고 있다. 중복된 숫자와 손실된 숫자를 묶어 반환하는 문제
- 나의 풀이: 아주 간단한 문제라고 생각했다. Counter로 세서 1개가 넘어가는 것을 일단 duplicated로, set으로 1~n 사이 중 존재하지 않는 숫자를 구했다.
- 다른 사람의 풀이: 수학적으로 풀었다. 총합과 제곱 총합을 이용해 풀었다.

### 0303 Missing Number
- 문제: 0 ~ n 사이의 숫자로 채워져야 하는 배열인데, 하나의 숫자가 제외된 배열이 주어졌을 때, 빠진 숫자가 무엇인지 맞추는 문제
- 나의 풀이: Bitwise exclusive or 연산을 사용하면 x ^ x = 0이고, 0 ^ x = x라는 특성을 이용해 0 ~ n사이 전체 숫자에 ^ 연산을 하고, 그 값에 주어진 배열 안에 있는 모든 원소들과 ^ 연산을 진행해 풀었다

### 0304 Intersection of Two Linked Lists
- 문제: 특정 지점부터 합쳐질 수도 있는 두 개의 Linked List가 주어졌을 때, 만약 두 Linked List가 합쳐진다면 합쳐지는 부분의 노드를 반환하는 문제. 공간복잡도 O(1), 시간복잡도 O(n)으로 풀어야 한다
- 나의 풀이: 일단 두 개의 linked list를 모두 끝까지 순회하면서 길이를 구하고, 더 긴 쪽은 차 만큼 next연산을 해 주어 남아 있는 길이를 맞춰 주었다. 이후 next연산을 하며 노드가 일치하는 곳이 발생하면 그 노드를 반환해 주었다. 끝까지 갔음에도 반환이 안된 경우 None 값을 반환했다.
- 다른 사람의 풀이: 천재적으로 푼 것 같다! ListA가 A + 공통, ListB가 B + 공통 부분이라고 할 때, 이 사람의 풀이대로 처음엔 listA의 포인터로 쓰던 것을 B의 포인터로, B의 포인터로 쓰던 것을 A의 포인터로 활용하게 되면 공통 부분까지 가는 데 A + 공통부분 + B 혹은, B + 공통부분 + A 만큼의 시간만 들게 된다. 만약 공통 부분이 없어서 None이더라도, 이는 동일하게 None으로 가기 때문에 두 포인터의 값이 같아진다

### 0305 Average of Levels in Binary Tree
- 문제: 트리의 각 층에서 값들의 평균을 내야 한다
- 나의 풀이: 트리를 순회하면서, 깊이에 따른 노드 리스트를 딕셔너리에 저장하고 깊이 별로 순회하며 평균을 낸 값을 정답 리스트로 만들었다
- 다른 사람의 풀이: 나의 경우 DFS 접근법 인데, BFS로 푼 분도 계셨다.

### 0306 Short Encoding of Words
- 문제: 단어들의 배열이 주어졌을 때, 해당 단어들을 합쳐 인코딩 한 결과물의 최소 길이를 반환하는 문제. 단, 각 단어 별로 인코딩 된 문장에서의 시작 위치가 있어야 하고, 단어 별로 시작 위치부터 #이 나오기까지가 그 단어와 일치해야 함. ex) ["time", "me", "bell"] => "time#bell#", [0, 2, 5]
- 나의 풀이: 한 단어가 다른 단어의 뒷부분과 일치하면(끝부터), 들어가지는 단어는 직접 분리해 쓰지 않아도 된다고 생각했다. 그래서 인코딩 할 때 쓰일 단어들의 셋을 따로 만들었다.단어들을 뒤집어서 정렬하고, 앞에 나온 단어가 뒤에 나온 단어에 포함될 수 있는지를 확인했다. 만약 포함이 된다면 인코딩할 때 쓰일 단어 집합에서 뺐다. 어차피 길이를 구하는 것이기 때문에, 따로 다시 변환해주지 않았다. #을 기준으로 합쳐졌을 때 길이가 어떻게 되는지를 구했는데, 다시 생각해보니 그냥 쓰일 단어들의 수 + 쓰일 단어들의 길이 합으로 구했어도 될 것이다. 시간 복잡도는 정렬할 때 드는 O(nlogn) 일 것이다. (이후 비교 시에는 O(n)의 시간이 든다)
- 다른 사람의 풀이: **Trie solution**이 있었다. Trie란 문자열을 저장하고 효율적으로 탐색하기 위한 트리 형태의 자료구조이다. O(M*L) 시간이 든다(L은 단어의 최대 길이). 


## 0307 Design HashMap
- 문제: 해쉬맵을 직접 클래스로 만들어 보는 문제
- 나의 풀이: key와 value에 대해 매칭되는 쌍끼리 같은 index를 갖도록 하고 각자 배열을 만들어 저장함
- 다른 사람의 풀이: (key, value) 쌍으로 이루어진 배열을 만듦

### 0308 Remove Palindromic Subsequences
- 문제: 문자 a와 b로 이루어진 문자열 s가 주어졌을 때, 한 번에 하나의 palindromic subsequence를 제거하면서 최종적으로 빈 문자열이 될 때까지 걸리는 최소 횟수를 구하는 문제
- 나의 풀이: 다른 사람들의 것과 동일한데, substring이었다면 어려운 문제였겠지만, subsequence이기 때문에 palindromic string이 아니라면 처음에 a를 모두 제거하고 뒤에 b를 모두 제거하면 된다. 빈 문장은 0, 길이가 1이거나 palindrome이면 1, 아니면 2를 반환하면 된다.