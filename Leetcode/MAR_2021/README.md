### 3월 문제 풀이 목록
- [0301_distribute_candies.py]()
- [0302_set_mismatch.py]()
- [0303 missing_nums.py]()
- [0304 intersect_linked_list.py]()
- [0305 average_bintree.py]()

### 0301 Distribute Candies
- 문제: 전체 캔디 수의 절반 만을 먹을 수 있는 앨리스가, 먹을 수 있는 캔디 종류의 최댓값을 구하는 문제
- 나의 풀이: 간단히, 캔디 종류의 수와 n//2 중 더 적은 값이 먹을 수 있는 종류 수의 최댓값이라고 풀었다.
- 다른 사람의 풀이: 캔디 종류 수를 구할 때 set 대신 Counter를 사용했다

### 0302 Set Mismatch
- 문제: 원래 배열에는 1 ~ n 의 숫자가 모두 포함되어 있다. 하지만, 한 숫자가 중복되어 원래 있어야 할 숫자를 대체하고 있다. 중복된 숫자와 손실된 숫자를 묶어 반환하는 문제
- 나의 풀이: 아주 간단한 문제라고 생각했다. Counter로 세서 1개가 넘어가는 것을 일단 duplicated로, set으로 1~n 사이 중 존재하지 않는 숫자를 구했다.
- 다른 사람의 풀이: 수학적으로 풀었다. 총합과 제곱 총합을 이용해 풀었다.

### 0303 Missing Number
- 문제: 0 ~ n 사이의 숫자로 채워져야 하는 배열인데, 하나의 숫자가 제외된 배열이 주어졌을 때, 빠진 숫자가 무엇인지 맞추는 문제
- 나의 풀이: Bitwise exclusive or 연산을 사용하면 x ^ x = 0이고, 0 ^ x = x라는 특성을 이용해 0 ~ n사이 전체 숫자에 ^ 연산을 하고, 그 값에 주어진 배열 안에 있는 모든 원소들과 ^ 연산을 진행해 풀었다

### 0304 Intersection of Two Linked Lists
- 문제: 특정 지점부터 합쳐질 수도 있는 두 개의 Linked List가 주어졌을 때, 만약 두 Linked List가 합쳐진다면 합쳐지는 부분의 노드를 반환하는 문제. 공간복잡도 O(1), 시간복잡도 O(n)으로 풀어야 한다
- 나의 풀이: 일단 두 개의 linked list를 모두 끝까지 순회하면서 길이를 구하고, 더 긴 쪽은 차 만큼 next연산을 해 주어 남아 있는 길이를 맞춰 주었다. 이후 next연산을 하며 노드가 일치하는 곳이 발생하면 그 노드를 반환해 주었다. 끝까지 갔음에도 반환이 안된 경우 None 값을 반환했다.
- 다른 사람의 풀이: 천재적으로 푼 것 같다! ListA가 A + 공통, ListB가 B + 공통 부분이라고 할 때, 이 사람의 풀이대로 처음엔 listA의 포인터로 쓰던 것을 B의 포인터로, B의 포인터로 쓰던 것을 A의 포인터로 활용하게 되면 공통 부분까지 가는 데 A + 공통부분 + B 혹은, B + 공통부분 + A 만큼의 시간만 들게 된다. 만약 공통 부분이 없어서 None이더라도, 이는 동일하게 None으로 가기 때문에 두 포인터의 값이 같아진다

### 0305 Average of Levels in Binary Tree
- 문제: 트리의 각 층에서 값들의 평균을 내야 한다
- 나의 풀이: 트리를 순회하면서, 깊이에 따른 노드 리스트를 딕셔너리에 저장하고 깊이 별로 순회하며 평균을 낸 값을 정답 리스트로 만들었다
- 다른 사람의 풀이: 나의 경우 DFS 접근법 인데, BFS로 푼 분도 계셨다.