# LeetCode 2월 문제 풀이 목록
- 0201 num_one_bits.py
- 0202 trim_bin_tree.py
- 0203 linked_list_cycle.py
- 0204 longest_harmonious_subseq.py
- 0205 simplify_path.py
- 0206 bintree_rightside.py
- 0207 shortest_to_character.py


### 0201 Number of 1 Bits
- 문제: 숫자가 주어졌을 때, 해당 숫자의 binary 표현(2의 보수 표현)에서 1의 갯수를 셈
- 나의 풀이: 파이썬의 라이브러리를 사용함
- 다른 사람의 풀이: 
    1. bit 을 움직여가면서 & 연산을 했고, 0이 아니라면 count를 증가시키는 방법
    2. n & (n-1)을 하면서 n이 0이 아닐 동안 진행하는 방법
- 아쉬운 점: 입력값이 특이하다 보니 직접 테스트 해볼 수 없었다

### 0202 Trim a Binary Search Tree
- 문제: Tree와 low, high 값이 주어졌을 때, 트리의 노드 중 값이 low와 high 사이에 들어 있지 않은 것을 빼야 한다
- 나의 풀이: dfs를 이용해 curr과 left와 right를 업데이트 해주었다
- 아쉬운 점: Binary search tree이기 때문에, 값들이 root를 기준으로 왼쪽은 더 작은 값들, 오른 쪽은 더 큰 값들이 있을 것이라는 걸 계산하지 못했다. 조건이 이렇게 안주겠거니 하는 생각은 있었지만.. 이를 적절히 활용하지 못했음

### 0203 Linked List Cycle
- 문제: 리스트 내에 사이클이 존재하는지 판별하는 문제이다.
- 나의 풀이: 노드의 갯수가 10^4개로 한정되어 있었기 때문에, 만약 현재 노드가 None이 아니고 next를 넘긴 횟수가 10^4 이하일 동안 계속 curr.next를 해주어 다음 노드로 넘어갔다. 사이클이 없다면 curr = None인 상태에서 끝나게 되므로 마지막에 curr != None을 리턴하여 사이클이 있다면 True를 반환하게 했다. 날로 먹기다.
- 다른 사람의 풀이: fast와 slow를 두고 두 개가 일치하게 되는 때가 있는지를 보았다. 언젠가는 겹치는 때가 생기는 것 같다 (이게 문제가 원한 풀이)

### 0204 Longest Harmonious Subsequence
- 문제: 리스트 내의 subsequence중 최댓값과 최솟값의 차가 정확히 1이 되는 subsequence의 길이를 찾아야 한다.
- 나의 풀이: 일단 list 내에 있는 모든 숫자들의 수를 세고, n이 있고 만약 n + 1 도 리스트 내에 있는 경우 n의 갯수와 n + 1의 갯수의 합의 최댓값을 답으로 한다. 좀 날로 먹은 것 같다
- 다른 사람의 풀이: 똑같이 풀었는데, 훨씬 멋지게 풀었다


### 0205 Simplify Path
- 쉘에 경로에 대한 문자열이 들어왔을 때, 이를 단순화 하는 과정이다.
- 나의 풀이: 정규표현식을 사용해 //가 두개 이상인 경우를 처리했고, 맨 오른쪽의 "/"를 없앴다. 쌓이는 경로들을 스택으로 처리했다. ..이 들어오면 스택에서 pop해주는 식이었다. 마지막에는 맨 앞에 "/"를 추가하고 파일 명 사이에 "/"를 두면서 하나의 문자열로 합쳤다.
- 다른 사람의 풀이: 생각해보니 "/"로 split할 것이므로 굳이 두 개짜리를 처리해주지 않아도 됐다... 하지만 아이디어는 똑같다!

### 0206 Binary Tree Right Side View
- 문제: 이진 트리를 오른쪽에서 본 값을 높이 별로 리스트에 담는 문제다
- 나의 풀이: 탐색을 하면서 왼쪽 먼저 탐색하게 하되, 이진 트리 내의 높이 별로 리스트를 만들고 트리 노드의 값을 담았다. 이후 각 리스트의 맨 마지막 원소가 해당 높이에서 가장 오른쪽에 있는 원소가 된다. DFS로 들어갔다
- 다른 사람의 풀이: 나처럼 dfs로 들어갔는데, 오히려 오른쪽 먼저 보게 해서 해당 높이에서 본 값이 없으면 이걸 맨 오른쪽 값이라고 쳤다! 이게 더 나은 듯 하다

### 0207 Shortest Distance to a Character
- 문제: 문장과 타깃 문자 c가 주어졌을 때, 문자열 내의 각 위치의 문자들로부터 c까지의 최소 거리를 구해 리스트로 반환한다.
- 나의 풀이: 우선 c의 모든 위치들에 대한 배열을 만들었고, 문자열을 돌며 만약 문자가 c와 일치하면 0, 아니라면 c 위치 리스트와 문자의 위치 사이 차의 최솟값을 구했다. 최솟값을 구할 때 c의 인덱스들 내에서 이진 탐색을 수행해 가장 가까운 양 옆의 두 index들과 현재 문자의 위치를 비교했다.