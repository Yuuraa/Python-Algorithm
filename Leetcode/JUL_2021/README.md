# 7월 리트코드 챌린지
### 문제 목록
1. Gray Code 
2. Find K Closest Elements
3. Max Sum of Rectangle No Larger Than K
4. Count Vowels Permutation
5. Reshape the Matrix
6. Reduce Array Size to The Half


### 0701 Gray Code
- 문제: n이 주어졌을 때, n개 bit으로 만들 수 있는 graycode를 찾는 문제
- 풀이: n을 구하기 전, n-1번째 gray code를 구하는 방식. 초기값은 0으로, bottom-up 방식으로 구현했다
    - n-1번째의 gray code의 마지막에 1을 붙인 것을 추가하다가, 끝에서 n-1번째 gray code를 역방향으로 돌며 마지막은 2로 끝이 난다
    - 가능한 이유: 모든 gray code가 0에서 시작하기 때문에, 이전 단계 첫 번째인 n-1개 0으로 이루어진 코드의 마지막에 1을 추가하면 0과 한 비트만 차이가 난다
    - 이전 단계 코드에 1을 끝에 붙이는 방식을 이어가면, 이전 단계에서 이미 1 bit씩 차이가 나도록 구해 두었기 때문에 정상적으로 동작한다
    - 이전 단계 코드를 모드 순회한 뒤 역순으로 0을 붙이기 시작하면, 끝에 1을 붙인 방식과 맨 끝 bit 차이만 나고, 이후에도 이전 단계에서 구한 대로 1 bit씩 차이가 난다
    - 모든 gray code의 마지막 숫자는 0과 1 bit 만 차이가 나도록 만들어졌기 때문에, 그 끝에 0을 붙여도 0과 1 bit만 차이가 난다
    - 이진수 표기 된 code의 마지막에 0을 붙이는 것은 숫자에 두배를 곱하는 것이고, 1을 붙이는 것은 두 배를 곱한 것에 1을 더한 것으로 이전 코드의 정수값으로부터 현재 코드의 정수값 배열을 계산할 수 있다

### 0702 Find K Closest Elements
- 문제: 정렬된 배열 arr와 숫자 x, 반환할 숫자의 갯수 k가 주어졌을 때, x와 가장 가까운 k개의 숫자들을 크기 순으로 정렬해 반환하는 문제. x 값과의 절대값 차가 작을수록, 숫자의 크기가 작을수록 가깝다
- 풀이:
    - 실제로 구하는 방법: 전체 배열을 순회하며 절댓값 차를 구하고, 가까운 순서대로 정렬한 뒤, k개의 element들을 정렬해 반환한다
        - 시간 복잡도가 O(nlogn)이 된다. 정렬을 다시 해야 하기 때문이다! 하지만 정렬된 배열을 입력으로 받으므로 이는 비효율적이다
    - 두 개의 포인터를 이용하는 방법: 배열의 첫 부분과 끝 부분에 포인터를 두고, x와의 값 차를 비교하며 만약 앞부분 포인터의 절댓값 차가 더 크다면 앞 포인터를 한 칸 뒤로 옮기고, 아니라면 뒤 포인터를 한 칸 앞으로 옮기며 k개의 원소 만이 사이에 남을 때까지 반복한다
        - 정렬된 배열에서 절댓값 차는 한 지점을 기준으로 왼쪽으로 갈 수록 연속적으로 감소, 오른쪽으로 갈 수록 증가한다. 따라서 두 개의 포인터를 두어 차가 더 큰 것을 제거해 나가면 k개의 closest element를 구할 수 있다
        - 시간 복잡도는 k가 1일 경우 최대 n-1 개의 비교를 하기 때문에 O(n)이 된다

### 0703 Max Sum of Rectangle No Larger Than K
- 문제: m x n 행렬과 정수 k가 주어졌을 때, 직사각형 submatrix의 원소의 합 중 k 이하의 최댓값을 구한다
- 풀이:
    - 

### 0704 Count Vowels Permutation
- 문제: 숫자 n 이 주어졌을 때, a, e, i, o, u로 만들 수 있는 n 길이의 문자열의 수를 구하는 문제. 단, a -> e, e -> a, i, i -> a, e, o, u, o -> i, u, u -> a 로 각 문자 뒤에 올 수 있는 문자들이 정해져 있다. 숫자가 너무 클 수 있으므로 10^9 + 7에 대한 나머지를 반환한다
- 풀이:
    - 문자열 길이를 1에서 시작해, 길이를 1씩 증가시킨다. 기존에 있는 문자들의 뒤에 올 수 있는 문자들을 붙이면 된다. 가짓수가 너무 많아질 수 있으므로 매 회 modulo 연산을 해준다
    - 시간 복잡도: O(n). 생성할 문자열의 길이 동안 5개의 문자 종류에 대해 갯수를 새롭게 구하는 연산이다

### 0705 Reshape the Matrix
- 문제: m*n 행렬을 주어진 r, c 크기로 바꾸되, 원본 데이터와 그 row-traversing 순서를 유지하는 reshape 함수를 구현한다. Reshape 형태가 legal 하다면, 즉 원본 행렬과 동일한 갯수의 원소를 갖는 행렬이어야만 하고, 아닌 경우 원본 행렬을 변화시키지 않는다
- 풀이:
    - r * c가 기존 m * n과 같은 값을 갖는지 확인한 뒤, 기존 행렬 내 모든 원소르르 row-traversing 순으로 순회하며 새로운 r, c에 맞추어 배열을 만든다
    - 시간 복잡도: O(m*n)

### 0706 Reduce Array Size to The Half
- 문제: 리스트 arr가 주어졌을 때, arr의 크기를 절반 이하로 줄이기 위해 제거해야하는 element set의 최소 갯수를 구한다
- 풀이:
    - Counter로 arr 내에서 element들의 등장 횟수를 잰다. 가장 많이 등장하는 element부터 순차적으로 등장 횟수를 추가하고, 그 합이 arr의 크기 절반 이하가 되면 지금까지 지운 element의 종류수를 반환한다