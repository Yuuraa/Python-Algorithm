# Shortest Path Algorithm
### Concepts
가장 짧은 거리를 구함. 한 지점 -> 다른 특정 지점, 모든 지점 -> 모든 지점 등 여러 유형 존재

**다익스트라**

방문하지 않은 노드 중 최단 거리가 가장 짧은 노드를 선택. 이를 위해 매 단계마다 1차원 리스트의 모든 원소를 순차 탐색함
- 특정 노드에서 출발해 다른 노드로 가는 각각의 최단 경로를 구해 (한 지점 -> 다른 특정 지점까지 최단 경로)
- 음의 간선이 없어야 함
- 그리디
- 모든 노드까지의 거리를 무한으로 초기화
- 힙을 사용하지 않을 시 시간 복잡도 O(V^2) 
- 힙 자료구조 사용시 O(ElogV)
    - 최단 거리 저장 리스트 + 현재 가장 가까운 노드 저장하는 우선순위 큐
    - **힙**: 우선순위 큐를 구현하기 위해 사용하는 자료구조.
        - 힙 정렬: O(NlogN)
        - **최소힙 -> 최대힙처럼 사용하려면 (-)를 붙여 사용**. 꺼낸 후 다시 (-)를 붙이는 테크닉!
    - **우선순위 큐**: 우선순위가 가장 높은 데이터를 가장 먼저 삭제
        - 파이썬 ```PriorityQueue``` 혹은 ```heapq``` 사용
        - ```heapq``` O(logN)으로 데이터 넣고 뺄 수 있음
        - ```PriorityQueue```는 최소 힙 기반 -> 다익스트라에 적합
        - 하나의 데이터를 삽입 및 삭제할 때 시간 복잡도 O(logN)
    0. 출발 노드에서 거리 0을 갖는 정보를 우선순위 큐에 넣음
    1. 우선순위 큐의 최상위 원소 = 거리 가장 짧은 원소를 꺼내고, 해당 노드를 이미 처리한 적 있다면 무시한다. 더 짧은 경로를 찾으면 최단거리 리스트의 값을 업데이트하고 우선순위 큐에 넣는다
    2. 우선순위 큐에서 원소를 꺼내 1의 과정을 반복한다.


**플로이드 워셜**
모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구함
- 다이나믹 프로그래밍 이용
- O(N^3) - N개의 단계 동안 O(N^2) 연산, 2차원 리스트 처리함



**벨만 포드**

### 예시 문제들
0. 다익스트라 알고리즘 최적화 전, 다익스트라 최적화 후(힙 이용), 플로이드 워셜 0_dijkstra_slow.py, 0_dijkstra_heap.py, 0_floyd_washall.py
1. 미래 도시 1_future_city.py
2. 전보 2_telegram.py