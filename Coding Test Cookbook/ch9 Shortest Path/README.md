# Shortest Path Algorithm
### Concepts
가장 짧은 거리를 구함. 한 지점 -> 다른 특정 지점, 모든 지점 -> 모든 지점 등 여러 유형 존재

**다익스트라**

방문하지 않은 노드 중 최단 거리가 가장 짧은 노드를 선택. 이를 위해 매 단계마다 1차원 리스트의 모든 원소를 순차 탐색함
- 특정 노드에서 출발해 다른 노드로 가는 각각의 최단 경로를 구해 (한 지점 -> 다른 특정 지점까지 최단 경로)
- 음의 간선이 없어야 함
- 그리디
- 모든 노드까지의 거리를 무한으로 초기화
- 힙을 사용하지 않을 시 시간 복잡도 O(V^2) 
- 힙 자료구조 사용시 O(ElogV)
    - 최단 거리 저장 리스트 + 현재 가장 가까운 노드 저장하는 우선순위 큐
    - **힙**: 우선순위 큐를 구현하기 위해 사용하는 자료구조.
        - 힙 정렬: O(NlogN)
        - **최소힙 -> 최대힙처럼 사용하려면 (-)를 붙여 사용**. 꺼낸 후 다시 (-)를 붙이는 테크닉!
    - **우선순위 큐**: 우선순위가 가장 높은 데이터를 가장 먼저 삭제
        - 파이썬 ```PriorityQueue``` 혹은 ```heapq``` 사용
        - ```heapq``` O(logN)으로 데이터 넣고 뺄 수 있음
        - ```PriorityQueue```는 최소 힙 기반 -> 다익스트라에 적합
        - 하나의 데이터를 삽입 및 삭제할 때 시간 복잡도 O(logN)
    0. 출발 노드에서 거리 0을 갖는 정보를 우선순위 큐에 넣음
    1. 우선순위 큐의 최상위 원소 = 거리 가장 짧은 원소를 꺼내고, 해당 노드를 이미 처리한 적 있다면 무시한다. 더 짧은 경로를 찾으면 최단거리 리스트의 값을 업데이트하고 우선순위 큐에 넣는다
    2. 우선순위 큐에서 원소를 꺼내 1의 과정을 반복한다.


**플로이드 워셜**
모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구함
- 다이나믹 프로그래밍 이용
- O(N^3) - N개의 단계 동안 O(N^2) 연산, 2차원 리스트 처리함



**벨만 포드**

### 예시 문제들
0. 다익스트라 알고리즘 최적화 전, 다익스트라 최적화 후(힙 이용), 플로이드 워셜 0_dijkstra_slow.py, 0_dijkstra_heap.py, 0_floyd_washall.py
1. 미래 도시 1_future_city.py
2. 전보 2_telegram.py

### 1_future_city.py
- 나의 아이디어: 1 ~ k 까지의 최단 거리를 구하고, k ~ 목적지 까지의 최단 거리를 구하면 될 것이라고 생각했다. 책에서는 플로이드 워셜 알고리즘을 이용했다. 다시 생각해보면, 특정 노드 -> 전체 노드 까지의 최단 거리를 구하는 것을 두 번 하는 과정이다. 나의 경우 두 번의 O(ElogN) 과정이고, 책의 구현의 경우 O(N^3)이므로 내 방식이 지저분하더라도 좀 더 나을 것이라고 생각했다.
- 책의 설명: 이 문제는 전형적인 플로이드 워셜 알고리즘 문제로, N <= 100이기 때문에 구현이 간단한 플로이드 워셜 알고리즘을 이용하는 것이 유리하다. **최단 거리 문제는 그림으로 먼져 그려보는 것이 좋다**
- 구현: 처음에는 dijkstra만 구현했는데, 약간의 모듈화를 포함해서 floid 방식도 추가해 보았다.

**TODO**
파이썬에서 변수들의 사용 scope에 대해 조사하기. 왜 어떤 것은 되고 어떤 것은 안되는지?

### 2_telegram.py
- 아쉬운 점: 오래 걸리는 시간, 총 시간이고 동시에 전보를 보내기 때문에, 마지막에 total time 을 구할 때 다 더하는 것이 아니라 max를 취해야 했다. 이를 파악하지 못해서 조금 더 시간이 들었다