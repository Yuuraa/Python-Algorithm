# Graph Algorithms

## Concepts
- 그래프: 노드와 노드 사이에 연결된 간선의 정보를 가진 자료구조. 연결된 객체들 표현
    - 구현 방법: 인접 행렬, 인접 리스트
- 트리: 힙도 트리 자료구조. 부모 -> 자식 계층적 모델로, 사이클이 없고 루트 노드 존재, 방향 그래프


어떤 문제를 만나더라도, 메모리와 시간을 염두에 두고 알고리즘을 선택해 구현해야 한다
=> **최단 경로 문제 시 노드의 수가 적은 경우 플로이드 워셜 이용가능, 노드와 간선 수가 모두 많으면 우선순위 큐를 이용하는 다익스트라 알고리즘**

### Union Find 알고리즘
- 서로소 집합: 공통 원소가 없는 두 집합
- 서로소 집합 자료구죄 서로소 부분 집합들로 나뉜 원소들의 데이터를 처리하기 위한 자료구조
    - 트리 자료구조 이용
    - union 연산을 확인해, 서로 연결된 A, B 확인하고 -> 모든 union 연산을 처리할 때까지 과정 반복
- **경로 압축** - find 함수를 수정해 find를 수행한 뒤 parent 값을 업데이트 하는 부분을 추가하면, 경로가 단축됨. 즉, find 한 이후 같은 그룹의 노드들이 parent로의 거리가 짧아짐
    
- **시간 복잡도** 
    - 경로 압축법을 이용할 경우: O(V + M(1 + log_{2-M/V}V))
    - 이용하지 않았을 경우: 최악의 경우 O(VM)이 되어 비효율적


### 최소 신장 트리 알고리즘
- **신장 트리**: 하나의 그래프가 있을 때 모든 노드를 포함하면서, 사이클이 존재하지 않는 부분 그래프 = 트리의 성립 조건
- 최소 신장 트리: 최소 비용으로 만들 수 있는 신장 트리


**크루스칼 알고리즘** 
그리디 알고리즘
1. 모든 간선에 대해 거리로 정렬한 뒤 가장 거리가 짧은 간선부터 집합에 포함시킴
2. 사이클을 발생시킬 수 있는 간선의 경우 포함 X
3. 모든 간선에 대해 위 과정 반복
- **구현** 
    - 원래 책에서는 edges에 포함 후 정렬했는데, 나는 **heapq** 라이브러리를 이용해 구현했다
    - 원래 책에서 언급되지 않았지만, 최소 신장 트리는 V개의 노드에 대해 V - 1개의 간선을 가져야 하기 때문에 이를 조건에 포함함
- **시간 복잡도**
    - 간선의 갯수 E -> O(ElogE)


### 위상 정렬
순서가 정해져 있는 일련의 작업을 차례대로 수행해야 할 때 사용할 수 있음. 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것
1. 진입차수(들어오는 간선의 수)가 0인 노드를 큐에 넣는다
2. 큐가 빌 때까지 다음의 과정을 반복한다
    1. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다
    2. 새롭게 진입차수가 0이 된 노드를 큐에 넣는다
=> 이 때, 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 판단할 수 있다

= 큐에서 원소가 V 번 추출되기 전에 큐가 비면 사이클이 발생한 것이다. 사이클이 존재하는 경우 사이클에 포함되어 있는 원소 중에서 어떠한 원소도 큐에 들어가지 못하기 때문이다.
- 만약 한 단계에서 큐에 새롭게 들어가는 원소가 2개 이상인 경우가 있다면, 여러 가지의 답이 존재하게 된다
- **시간 복잡도**
    O(V+E)이다. 차례대로 모든 노드를 확인하면서, 해당 노드에서 출발하는 간선을 차례대로 제거해야 한다. 결과적으로 노드와 간선을 모두 확인하므로 O(V+E)




## 예시 문제들
0. 서로소 집합-기본 경로 압축 적용, 사이클 판별, 크루스칼, 위상 정렬 0_union_find.py, 0_cycle.py, 0_kruskal.py, 0_topological_sort.py
1. 팀 결성 1_team_organization.py
2. 도시 분할 계획 2_city_division.py
3. 커리큘럼 3_curriculum.py

### 1. 팀 결성

### 2. 도시 분할 계획

### 3. 커리큘럼