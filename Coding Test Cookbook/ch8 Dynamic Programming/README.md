# Dynamic Programming Algorithm
### Concepts
- 메모리 공간을 약간 더 사용하면서 중복 계산을 줄이고 연산 속도를 증가시킨다
- 큰 문제를 작게 나눈다 -> 문제들이 서로 영향을 미침
- 재귀함수 보단 반복문
- Top-down: 재귀함수 이용, 큰 문제 해결 위해 작은 문제 호출. 재귀 제한 완화: sys 라이브러리의 setrecursionlimit() 메소드
- Bottom-up: 단순 반복문 이용, 작은 문제부터 차근차근 답 도출
- 메모이제이션: 이전에 계산된 결과를 일시저긍로 기록해 놓는 넓은 개념. 때에 따라 수열처럼 연속적이지 않은 경우 dict 자료형이 유용함

### 예시 문제들
1. 1로 만들기 1_make_to_one.py
2. 개미 전사 2_ant_warrior.py
3. 바닥 공사 3_flooring_work.py
4. 효율적인 화폐 구성 4_efficient_money_composition.py


### 1_make_to_one.py
- 아쉬운 점: 가급적이면 반복문으로 짜야하는데, 재귀함수로 작성했음. 내 생각에는 값을 띄엄 띄엄 구하게 될 것 같아 top-down을 채택했는데, 책에서는 bottom-up으로 구현했다. 차근 차근 하는 방식에 대한 불신이 있는듯..

### 2_ant_warrior.py
- 비슷한 문제: 계단 오르기
- 나의 아이디어: 만약 바로 직전의 창고를 훔쳤다면, 이번 창고에서는 훔칠 수 없다. 직전의 창고를 훔치지 않았다면, 이번 창고에서 훔칠 수 있다. 두 가지 경우를 분리하여 생각하면
    - dp[i][0]: 직전 단계의 창고를 훔쳤을 때, i 번째 창고까지에서 얻을 수 있는 최대 식량 = max(dp[i-1][0], dp[i-1][1]). (이번 창고에서는 훔칠 수 없으므로, 직전까지 훔칠 수 있는 최댓값)
    - dp[i][1]: 직전 단계의 창고를 훔치지 않았을 경우, i - 2번째 창고까지에서 얻을 수 있는 최대 식량 =  max(dp[i-2][0], dp[i-2][1]) + 이번 창고에 들어 있는 식량의 양
    
    이렇게 구하다 보면, 마지막 창고까지 오면서 훔칠 수 있는 식량의 최댓값을 max(dp[n-1][0], dp[n-1][1])로 구할 수 있음

- 책의 아이디어: 
    내 아이디어에서 아쉬운 점: 굳이 배열을 두 개 만들지 않아도 되었음..
    dp[i] = max(dp[i-1], dp[i-2] + food_list[i])

### 3_flooring_work.py
- 다시 풀어 보아야 한다
- 왼쪽부터 차례로 타일을 채운다고 생각해야 한다

### 4_efficient_money_composition.py
- 내 아이디어:
    - 동전의 갯수는 최대여도 10001개를 넘지 못하게 때문에, 이를 최댓값으로 각 "돈"에 대해 동전의 수를 저장했다. 초기화를 10001로 잡았다.
    - 동전 한 개로 만들 수 있는 돈들에는 모두 1을 대입했다.
    - 동전의 종류를 저장해두고, 정렬한 뒤 각 돈의 양마다 동전의 값들을 순회하며, 동전의 값이 돈의 양보다 많으면 break 하는 식으로 돈의 양마다 동전의 값을 순회하며 최소 동전의 갯수를 채워 나갔다.
 
